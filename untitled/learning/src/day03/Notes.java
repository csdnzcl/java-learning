package day03;

public class Notes {
}

/*
什么是包：包就是文件夹。用来管理各种不同功能的java类，方便后期代码维护
命名规则：公司域名反写 + 包的作用----小写

导包规则（import)：
    1. 使用同一个包中的类、使用java.lang包中的类---不需要导包
    2. 其余均需要导包
    3. 如果同时使用两个包中的同名类，需要用全类名eg:day03.Final.Student = new ……


Final关键字：（最终版）
    1. 修饰方法---最终方法，不能被重写--public final void show(){……}
    2. 修饰类----最终类，不能被继承--public final class String{}
    3. 修饰变量---常量(数据值/地址值恒定），只能被赋值一次--public final int a = 10;


权限修饰符：
    private(同一个类） < 空（同一个包） < protected < public
                                    不同包子类
    成员变量私有，方法公开

静态代码块：static{}   随着类的加载而加载，并且只执行一次
*/

/*
抽象类和抽象方法
抽象方法：将共性的行为（方法）抽取到父类，在父类中不能确定具体的方法体
    格式：public abstract 返回值类型 方法名();
抽象类：存在抽象方法的类  必须声明为抽象类
    格式：public abstract class 类名 {}
抽象类不能实例化，                       不一定有抽象方法
    抽象类子类： 1. 重写抽象类中所有抽象方法  2. 也是抽象类


 */

/*
接口(interface)：一种规则，对行为的抽象
    定义：public interface 接口名 {}
    接口不能实例化，接口和类之间是实现关系（可以单/多实现），关键字implements表示
    eg:public class 类名 implements 接口1, 接口2 {}
    接口的子类（实现类）：要门重写接口中的抽象方法，要么为抽象类

接口中成员的特点：
    成员变量：只能是常量，默认修饰符：public static final
    没有构造方法
    成员方法：JDK7以前，接口中只能定义抽象方法(默认public abstract)
        JDK8新特性：接口中可以定义有方法体的方法(默认，静态）--解决接口升级问题
            默认方法：（public） default 返回值类型 方法名（）{}
                非抽象方法，不强制重写， 重写需要去掉default关键字
            静态方法：（public) static 返 方法名() {}   不能重写
                只能通过接口名调用 ，不能通过实现类名或者对象名调用
        JDK9新特性：可定义私有方法
            1. 默认：private (default) void show() {}
            2. 静态：private static void show() {} //给静态方法服务

接口多态：当一个方法的参数是接口时，可以传递接口所有实现类的对象（编译看左，运行看右）

设计模式：被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结

适配器设计模式：只需要使用接口中一部分的时候就可以适配器设计模式
    书写步骤：编写中间类XXXAdapter，实现对应接口，空实现
            让真正的实现类继承中间类，并重写需要用的方法

            为了避免其他类创建适配器类的对象，中间的适配器类用abstract修饰
 */

/*
内部类：
    内部类可以直接访问外部类的成员，包括私有
    外部类要访问内部类的成员，必须创建对象

内部类的分类：成员/静态/局部内部类，  (important)匿名内部类
    成员内部类： 可以被一些修饰符修饰
    `   对象获取方式：
             1. 外部类编写方法，对外提供内部类对象
             2. 外部类类名.内部类名 对象名 = 外部类对象.内部类对象
                eg: Outer.Inner oi = new Outer().new Inner();

    静态内部类（成员内部类中一种）：只能访问外部类中的静态……非静态需要创建对象
        创建格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();
        调用静态方法格式：外部类名.内部类名.方法名（）；
        调用非静态方法格式：先创建对象， 用对象调用


    匿名内部类：隐藏了名字的内部类---应用：实现类只要使用一次
    格式：  new 类名/接口名（） {
               重写方法;
           };  //实际这个整体是一个对象

    eg: public static void method (Animal a) {
            a.eat(); }
        method(
                new Anima(){
                    @override
                    public void eat() {
                        System.out.println("够吃骨头");
                    }
               );  //不需要重新创建Dog类方便（Dog类只需要使用一次）
 */